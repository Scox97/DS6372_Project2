---
title: "Project 2 Predicting Salary"
author: "Adam Ercanbrack"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load_packages, echo=FALSE}
library(tidyverse)
library(dplyr)
library(plyr)
library(tidyr)
library(lmtest) # Durban-Watson test for independence
library(car)
library(corrplot)
library(jtools)
library(sjPlot)
library(ResourceSelection)
library(ROCR)
library(pROC)
library(ggplot2)
library(naniar)  #for visualizing missing data
```
# Key question for this study: Is it possible to predict when someone is likely to make over 50k? 
* Secondary question: What variables best predict a subject making over 50k?


# Data Descriptions:
Variable Name	Role	Type	Demographic	Description	Units	Missing Values
* age	Feature	Integer	Age	N/A		no

* workclass	Feature	Categorical	Income	Private, Self-emp-not-inc, Self-emp-inc, Federal-gov, Local-gov, State-gov, Without-pay, Never-worked.		yes

* fnlwgt	Feature	Integer				no

* education	Feature	Categorical	Education Level	Bachelors, Some-college, 11th, HS-grad, Prof-school, Assoc-acdm, Assoc-voc, 9th, 7th-8th, 12th, Masters, 1st-4th, 10th, Doctorate, 5th-6th, Preschool.		no
* education-num	Feature	Integer	Education Level			no

* marital-status	Feature	Categorical	Other	Married-civ-spouse, Divorced, Never-married, Separated, Widowed, Married-spouse-absent, Married-AF-spouse.		no

* occupation	Feature	Categorical	Other	Tech-support, Craft-repair, Other-service, Sales, Exec-managerial, Prof-specialty, Handlers-cleaners, Machine-op-inspct, Adm-clerical, Farming-fishing, Transport-moving, Priv-house-serv, Protective-serv, Armed-Forces.		yes

* relationship	Feature	Categorical	Other	Wife, Own-child, Husband, Not-in-family, Other-relative, Unmarried.		no

* race	Feature	Categorical	Race	White, Asian-Pac-Islander, Amer-Indian-Eskimo, Other, Black.		no

* sex	Feature	Binary	Sex	Female, Male.		no

* capital-gain	Feature	Integer				no

* capital-loss	Feature	Integer				no

* hours-per-week	Feature	Integer				no

* native-country	Feature	Categorical	Other	 [1] ""                            " ?"                          " Cambodia"                   " Canada"                    
 [5] " China"                      " Columbia"                   " Cuba"                       " Dominican-Republic"        
 [9] " Ecuador"                    " El-Salvador"                " England"                    " France"                    
[13] " Germany"                    " Greece"                     " Guatemala"                  " Haiti"                     
[17] " Holand-Netherlands"         " Honduras"                   " Hong"                       " Hungary"                   
[21] " India"                      " Iran"                       " Ireland"                    " Italy"                     
[25] " Jamaica"                    " Japan"                      " Laos"                       " Mexico"                    
[29] " Nicaragua"                  " Outlying-US(Guam-USVI-etc)" " Peru"                       " Philippines"               
[33] " Poland"                     " Portugal"                   " Puerto-Rico"                " Scotland"                  
[37] " South"                      " Taiwan"                     " Thailand"                   " Trinadad&Tobago"           
[41] " United-States"              " Vietnam"                    " Yugoslavia"                		yes
income	Target	Binary	Income	>50K, <=50K.		no

Note: 
* fnlwgt (third column) - change to 'similar_pop_count' represents the number of subjects in the target population that the responding subject represents.
* education_num - change to 'years_eduction' - count of total years in school
* sex - changed to 'gender'
```{r pressure, echo=FALSE}
# setwd("D:/University/SMU/Applied Statistics/Project2")
# adult<-read.csv("50_or_More.csv",stringsAsFactors = T)
adult<-read.csv("adult.csv",stringsAsFactors = T)

colnames(adult) <- c('age', 'workclass', 'similar_pop_count', 'education_level', 
                     'years_education', 'marital_status', 'occupation', 'household_role', 'race', 'gender', 
                     'capital_gain', 'capital_loss', 'hours_per_week', 'native_country', 'income')

adult
```


# Tidying Data and resolving missing values:
*  First get a card of missing values per column and then count them. 
**   Findings: Of 32562 data values 15 are missing (less than 0.1 percent missing).
```{r Visualize_missing_values}

#Checking data types
str(adult)
cat("\n------------------Count NA----------------------\n\n")
sort(colSums(is.na(adult)), decreasing = TRUE)
vis_miss(adult)
dim(adult)
```

# Most of the variables are categorical. To Better analyze them, we will:
  1. Reclassified values into value groups to reduce levels ahead of any EDA and predictions.
  2. replaced the remaining 15 missing values with averages.
```{r reduce_levels}
# Function to recode the values with trimmed spaces
recode_value <- function(old_level) {
  old_level <- trimws(old_level) # Trim leading and trailing whitespace
  for (category in names(new_levels)) {
    if (old_level %in% new_levels[[category]]) {
      return(category)
    }
  }
  return(NA) # Return NA if the education level does not match any category
}

levels(adult$workclass)<- c("unemployed", "unemployed","FedGov","LocGov","NeverWorked","Private",
                                   "SelfEmpInc","SelfEmpNotInc","StateGov","unemployed")


# The new education level categories
new_levels <- list(
  no_edu = c("", "Preschool"),
  primary = c("1st-4th", "5th-6th"),
  secondary = c("7th-8th"),
  highsch = c("9th", "10th", "11th", "12th", "HS-grad"),
  assoc = c("Assoc-acdm", "Assoc-voc", "Some-college"),
  undergrad = c("Bachelors", "Prof-school"),
  master = c("Masters"),
  phd = c("Doctorate")
)

# Recode the education levels with the updated function
adult$education_level <- sapply(adult$education_level, recode_value)

# recreate the levels
levels(adult$education_level)<- c("no_edu", "primary", "secondary", "highsch", "assoc", "undergrad", "master", "phd")

# The new marital status categories
new_levels <- list(
  divorce = c("Divorced", "Separated"),
  married = c("Married-AF-spouse", "Married-civ-spouse", "Married-spouse-absent"),
  notmarried = c("", "Never-married"),
  widowed = c("Widowed")
)

# Recode the marital statuses with the updated function
adult$marital_status <- sapply(adult$marital_status, recode_value)

# recreate the levels
levels(adult$marital_status)<- c("divorce", "married", "notmarried", "widowed")


new_levels <- list(
  other = c("", "?"),
  clerical = c("Adm-clerical"),
  midskill = c("Craft-repair", "Machine-op-inspct", "Transport-moving"),
  lowskill = c("Handlers-cleaners", "Other-service", "Priv-house-serv", "Armed-Forces"),
  highskill = c("Sales", "Tech-support", "Protective-serv", "Prof-specialty", "Exec-managerial"),
  agriculture = c("Farming-fishing")
)


# Recode the marital statuses with the updated function
adult$occupation <- sapply(adult$occupation, recode_value)

# recreate the levels
levels(adult$occupation)<- c("other", "clerical", "midskill", "lowskill", "highskill", "agriculture")


# Define the new levels for household_role
new_levels <- list(
  husband = c("Husband"),
  wife = c("Wife"),
  tenant = c("Not-in-family"),
  single_occ = c("Unmarried", ""),
  relative = c("Other-relative"),
  depchild = c("Own-child")
)

# Recode the household_role column using the recode function
adult$household_role <- sapply(adult$household_role, recode_value)

# Convert the recoded household_role to a factor
adult$household_role <- factor(adult$household_role, levels = names(new_levels))

# Define the new levels for native_country
new_levels <- list(
  EAsia = c("Vietnam", "Laos", "Cambodia", "Thailand", "China", "Hong", "Taiwan", "Philippines", "Japan"),
  SAsia = c("India", "Iran"),
  NorthAmerica = c("Canada", "Mexico", "United-States"),
  CentrAmerica = c("Cuba", "Dominican-Republic", "Guatemala", "Haiti", "Honduras", "Jamaica", "Trinadad&Tobago", "Nicaragua", "El-Salvador", "", "?"),
  SouthAmerica = c("Ecuador", "Peru", "Columbia", "South"),
  Europe = c("France", "Germany", "Greece", "Holand-Netherlands", "Italy", "Hungary", "Ireland", "Poland", "Portugal", "Scotland", "England", "Yugoslavia"),
   USTerritory = c("Outlying-US(Guam-USVI-etc)", "Puerto-Rico")
)

# Recode the native_country column using the recode function
adult$native_country <- sapply(adult$native_country, recode_value)

# Convert the recoded native_country to a factor
adult$native_country <- factor(adult$native_country, levels = names(new_levels))
levels(adult$native_country)


# Define the new levels for income
new_levels <- list(
  "<=50K" = c("<=50K", ""),
  ">50K" = c(">50K")
)

# Recode the incomer column using the recode function
adult$income <- sapply(adult$income, recode_value)

# Convert the recoded native_country to a factor
adult$income <- factor(adult$income, levels = names(new_levels))
levels(adult$income)

# Define the new levels for gender
new_levels <- list(
  "female" = c("Female", ""),
  "male" = c("Male")
)

# Recode the incomer column using the recode function
adult$gender <- sapply(adult$gender, recode_value)

# Convert the recoded native_country to a factor
adult$gender <- factor(adult$gender, levels = names(new_levels))
levels(adult$gender)

# Define the new levels for race
new_levels <- list(
  other = c("Other", ""),
  white = c("White"),
  black = c("Black"),
  native = c("Amer-Indian-Eskimo"),
  Asian_Pac_Islander = c("Asian-Pac-Islander")
)

# Recode the incomer column using the recode function
adult$race <- sapply(adult$race, recode_value)

# Convert the recoded native_country to a factor
adult$race <- factor(adult$race, levels = names(new_levels))
levels(adult$race)

# get the average of all remaining missing values
replace_missing_with_average <- function(data) {
  for (col_name in names(data)) {
    # Check if the column is numeric
    if (is.numeric(data[[col_name]])) {
      # Calculate the average, excluding NA values
      column_mean <- mean(data[[col_name]], na.rm = TRUE)
      # Replace NA values with the column's average
      data[[col_name]][is.na(data[[col_name]])] <- column_mean
    }
  }
  return(data)
}

# Call the replace function:
adult <- replace_missing_with_average(adult)

# Make sure categorical variables are factored
adult[] <- lapply(adult, function(x) if(is.character(x)) as.factor(x) else x)

# Review changes
adult

```


# Verify all missing values are adjusted.
```{r recheck_missing_values}

#Checking data types
str(adult)
cat("\n------------------Count NA----------------------\n\n")
sort(colSums(is.na(adult)), decreasing = TRUE)
vis_miss(adult)
dim(adult)
```


# EDA of the variables
```{r eda_age_hours}
# histogram of age by income group
ggplot(adult) + aes(x=age, group=income, fill=income) + 
  geom_histogram(binwidth=1, color='black')

ggplot(adult, aes(x = income, y = age, colour = income, fill = income)) +
  geom_boxplot(color='black') +
  ggtitle("Earnings by Age")

ggplot(adult, aes(x = income, y = age, color=income, fill=income)) + 
  geom_boxplot(color='black') +
  facet_grid(. ~ native_country) +
  ggtitle("Earnings by Age and Origin")

ggplot(adult) + aes(x=hours_per_week, group=income, fill=income) + 
  geom_histogram()+
  facet_grid(. ~ occupation) 

# Income by race with percentage
ggplot(adult, aes(x = hours_per_week, fill = income)) +
  geom_bar(position = "fill") +
  facet_grid(. ~ occupation) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(y = "Percentage")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

ggplot(adult, aes(x = income, y = hours_per_week, colour = income, fill = income)) +
  geom_boxplot(color='black') +
  facet_grid(. ~ gender) +
  ggtitle("Earnings by Gender and Hours Worked")

# Hourse worked
ggplot(adult, aes(x = race, y = hours_per_week, colour = income, fill = income)) +
  geom_boxplot(color='black') +
  ggtitle("Earnings by Race and Hours Worked")

ggplot(adult, aes(x = marital_status, y = hours_per_week, colour = income, fill = income)) +
  geom_boxplot(color='black') +
  ggtitle("Earnings by Marital Status and Education")
```


```{r eda_race_edu_occ}
# Income by occupation
qplot(occupation, data = adult, fill = income) + facet_grid (. ~ race)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

# Income by race with percentage
ggplot(adult, aes(x = occupation, fill = income)) +
  geom_bar(position = "fill") +
  facet_grid(. ~ race) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(y = "Percentage")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

# Hourse worked
ggplot(adult, aes(x = occupation, y = hours_per_week, colour = income, fill = income)) +
  geom_boxplot(color='black') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  facet_grid(. ~ race)+
  ggtitle("Earnings by Race, Occupation, and Hours Worked")

# Income by race
qplot(education_level, data = adult, fill = income) +
  facet_grid(. ~ race) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

# Income by race with percentage
ggplot(adult, aes(x = education_level, fill = income)) +
  geom_bar(position = "fill") +
  facet_grid(. ~ race) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(y = "Percentage")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

ggplot(adult, aes(x = race, y = years_education, colour = income, fill = income)) +
  geom_boxplot(color='black') +
  ggtitle("Earnings by Race and Education")


```


```{r eda_gender_status}

# Hourse worked
ggplot(adult, aes(x = gender, y = hours_per_week, colour = income, fill = income)) +
  geom_boxplot(color='black') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  facet_grid(. ~ race)+
  ggtitle("Earnings by Race, Gender, and Hours Worked")

ggplot(adult, aes(x = gender, y = years_education, colour = income, fill = income)) +
  geom_boxplot(color='black') +
  ggtitle("Earnings by Gender and Education")

ggplot(adult, aes(x = marital_status, y = hours_per_week, colour = income, fill = income)) +
  geom_boxplot(color='black') +
  ggtitle("Earnings by Marital Status and Hours")

# Income by gender
qplot(race, data = adult, fill = income) +
  facet_grid(. ~ marital_status) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  ggtitle('Earnings with Race and Marital Status')


```


```{r eda_occupation_education}
# Income by occupation
qplot(income, data = adult, fill = income) + facet_grid (. ~ occupation)+
  ggtitle('Earnings with Occupation')

# Income by education
qplot(income, data = adult, fill = income) + facet_grid (. ~ education_level)+
  ggtitle('Earnings with Education')

# Income by race
qplot(education_level, data = adult, fill = income) +
  facet_grid(. ~ race) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  ggtitle('Earnings with Race and Education')

# Income by race with percentage
ggplot(adult, aes(x = education_level, fill = income)) +
  geom_bar(position = "fill") +
  facet_grid(. ~ race) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(y = "Percentage")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  ggtitle('Earnings with Race and Education (Percentage')

```

```{r eda_capital_Gain_loss}
# Income by gain
qplot(capital_gain, data = adult, fill = income)+
  ggtitle('Earnings with Capital Gains')

# Income by loss
qplot(capital_loss, data = adult, fill = income)+
  ggtitle('Earnings with Capital Loss')

```


#Check Logistic Assumptions:
* Assumption 1: Is the response variable binary?
```{r binary_check}
# Assure it is a factor
adult$income <- factor(adult$income, levels = c("<=50K", ">50K"))
levels(adult$income)

# Visual inspection (example with 'age' as a predictor)
ggplot(adult, aes(x = age, fill = income)) + geom_histogram(position = "dodge")

```


# Assumption 2: Independence of Observations
* The Durbin-Watson statistic (DW) is close to 2 (DW = 1.9966), which indicates no autocorrelation, and the high p-value (p-value = 0.3786) means that you fail to reject the null hypothesis of no autocorrelation
```{r independence_check}
# Fit the logistic regression model
model <- glm(income ~ ., data = adult, family = binomial)

# Perform the Durbin-Watson test
dw_result <- dwtest(model)
dw_result

```

# Assumption 3: No Multicollinearity among predictors.
* All Variance Inflation Factors (VIFs) are below 5 and visually verified as not being highly correlated.
* Note: a VIF value below 5 suggests that there is no significant multicollinearity among the predictors, and values below 10 are often considered acceptable.
```{r multicollinearity_check}
adult_dum <- adult
# one-hot-encode income
adult_dum$income <- ifelse(adult_dum$income == "<=50K", 0, 1)

# Loop through columns
for (col in names(adult_dum)) {
  if (is.factor(adult_dum[[col]])) { # Check if column is a factor
    levels <- levels(adult_dum[[col]]) # Get levels of the factor
    adult_dum[[col]] <- as.numeric(factor(adult_dum[[col]], levels = levels)) # Convert factor to numeric based on levels
    names(adult_dum)[names(adult_dum) == col] <- paste0(col, "_num") # Rename the column
  }
}

adult_dum

# Fit logistic regression model
model2 <- glm(income ~ ., family = binomial, data = adult_dum)

# Calculate VIF
vif_values <- vif(model2)
print(vif_values)

# Visualize correlation matrix of predictors
# Visualize correlation matrix of predictors
cor_matrix <- cor(select(adult_dum, -income))
corrplot(cor_matrix, method='circle')

```


# Assumption 4: Check for Extreme Outliers
* There are three outliers that need to be removed.
* Note: Data points with an absolute standardized residuals above 3 represent possible outliers and may deserve closer attention.
```{r}
library(broom)
plot(model, which = 4, id.n = 10)

# Extract model results
model.data <- augment(model) %>% 
  dplyr::mutate(index = dplyr::row_number())  # Use row_number() instead of n()

model.data %>% top_n(3, .cooksd)

ggplot(model.data, aes(index, .std.resid)) + 
  geom_point(aes(color = income), alpha = 0.5) +
  theme_bw()

# Remove influential data points
model.data %>% 
  filter(abs(.std.resid) > 3)
```

# Assumption 5: Linearity Assumption 
* For categorical predictors, the concept of linearity doesnâ€™t apply in the traditional sense because these variables are represented in the model as a series of dummy variables (one for each category, minus one reference category).
* Because the dependent variable is categorical and any transformation to dummy variables would automatically mean a linear relationship, you don't have to do this assumptions check on the categorical. Below are just some tests.
```{r}
ggplot(adult_dum,(aes(x=age,y=income)))+geom_point()+geom_smooth(method="loess",span=.1)

ggplot(adult_dum,(aes(x=years_education,y=income)))+geom_point()+geom_smooth(method="loess",span=.6)

# Check for linearity in continuous variables
boxTidwell(income ~ age + years_education, data = adult_dum)
```


# Post EDA/assumption check data-split to train and test sets
```{r create_train_test}
# Set a seed for reproducibility
set.seed(1234)

# Calculate the number of rows to select
sample_size <- round(0.8 * nrow(adult))

# Create a random sample of indices
index <- sample(1:nrow(adult), size = sample_size, replace = FALSE)

# Create the training set using the selected indices
training_set <- adult[index, ]

# Create the testing set with the remaining indices
testing_set <- adult[-index, ]
nrow(training_set_LR)
nrow(testing_set_LR)

testing_set
```


```{r}

# Fit a logistic regression model
model3 <- glm(income ~ ., data = training_set, family = binomial('logit'))
summary(model3)


```

```{r}
confint(model3)
```



